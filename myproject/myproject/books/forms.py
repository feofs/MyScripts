#Библиотека для работы с формами, предназначенна для решения многих проблем, например для проверки валидности введных данных, без всяких ручных решений
from django import forms
from django.http import HttpResponse
#В общем типа описания моделей
#у полей также имеются различные опции например, max_length и так понятно и widget=forms.Textarea - выбор виджета для поля
#Также есть еще и метки, которые Джанго автоматически формирует, он заменяет _ пробелами а первую букву переводит в верхний регистр
#но можно задать метки и вручную label='Ваш E-mail'
class ContactForm(forms.Form):
    subject=forms.CharField(max_length=100)
    email=forms.EmailField(required=False,label='Ваш E-mail')
    message=forms.CharField(widget=forms.Textarea)

    #Правила проверки, их можно создвать как отдельные функции, или же если часто применяются можно создать отдельное поле со своим типом, но для разовой проерки можно написать свой метод в классе
    #cуть в чем, что есть опредленные правила, например Джанго ищет методы проверки, эти методы должны начинаться с имени clean и названия поля в конце
    #если он его найдет в классе формы он выполнит этот код проверки применительно к полю то есть к данным введенным в поле после всех остальных проверок
    def clean_message(self):
        #так кка эта проверка идет после стандартных обработок то можно не думать, что поля не существует или пустое это уже проверил стандартный обрабтчик и сформировал словарь cleaned_data из ключей - имен полей офрмы
        #и значений - значений формы
        message=self.cleaned_data['message']
        #Для начала разделим сообщение по пробелам и получим длину массива
        num_words=len(message.split())
        #if 'frf' not in message:
         #   pass
            #pass
            #self['message'].errors.append('Слишком мало слов')
        raise forms.ValidationError('Слишком мало слов в сообщениий')
            #return HttpResponse('Слишком мало слов')
        return HttpResponse(message)


#Что это класс умеет деалть, прежде всего в строковом представлении он представляет из себя HTML страницу с формой
'''
<tr><th><label for=”id_subject”>Тема:</label></th><td>
<input type=”text” name=”subject” id=”id_subject” /></td></tr>
<tr><th><label for=”id_e-mail”>E-mail:</label></th><td>
<input type=”text” name=”e-mail” id=”id_e-mail” /></td></tr>
<tr><th><label for=”id_message”>Сообщение:</label></th><td>
<input type=”text” name=”message” id=”id_message” /></td></tr>
Django добавляет к каждому полю метку, а также теги <label> для поль-
зователей с ограниченными возможностями. Идея в том, чтобы поведе-
ние по умолчанию было оптимальным.

По умолчанию ввыодиться в виде таблицы но можно и в виде списка
#f=ContactForm()
#print(f.as_ul())
Теги <table> и <ul> открываюшие и закрывающие не добавляются, чтобы сами могли придумать декор таблицы

Для связности нужно передать в нее данные, то есть ассоцировав данные с формой мы создали связную форму
даж
f.is_bound - проверяет данные на связность с формой, то есть заполненна ли она
f = ContactForm({'subject': 'Привет', 'message': 'Отличный сайт!'})
>>> f.is_valid()

True

А is_valid - проверит поля формы, даже если будет не заполненно поле почты, так как оно не обязательноке

Также можно обращая f.['message'].errors - получить данные о проверке и ошибках полей
= ContactForm({‘subject’: ‘Привет’, ‘message’: ‘’})
>>> f[‘message’].errors
[u’This field is required.’]
>>> f[‘subject’].errors
[]
>>> f[‘e-mail’].errors
[]

Также есть и общий словарь f.errors - который хранит имена полей и их ошибки
{‘message’: [u’This field is required.’]}

А свойство cleaned_data - это типичный словарь Питон с именем поля в качестве ключа и ее значением

'''
#f=ContactForm()
#print(f)