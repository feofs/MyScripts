'''
Вот можно стандартно подключиться к БД и вернуть список, окторый потом пролистать в представлении
from django.shortcuts import render_to_response
import MySQLdb
777-888-999
def book_list(request):
db = MySQLdb.connect(user=’me’, db=’mydb’,
passwd=’secret’, host=’localhost’)
cursor = db.cursor()
cursor.execute(‘SELECT name FROM books ORDER BY name’)
names = [row[0] for row in cursor.fetchall()]
db.close()
return render_to_response(‘book_list.html’, {‘names’: names})

Так делать можно, но сразу же возникает целый ряд проблем:
•• Мы «зашили» в код параметры соединения с базой данных. В идеале
они должны храниться в файле с настройками Django.
•• Приходится писать много шаблонного
кода: создать соединение, соз-
дать курсор, выполнить команду и закрыть соединение. Хотелось
бы, чтобы можно было просто сказать, какие данные нужны.
•• Мы жестко связали себя с MySQL. Если позже мы захотим перей-
ти с MySQL на PostgreSQL, то придется взять другой адаптер базы
данных (psycopg вместо MySQLdb), изменить параметры соединения и –
в зависимости от характера SQL-команды – быть может, переписать
запрос. В идеале СУБД должна быть абстрагирована, так чтобы при
смене СУБД было достаточно внести изменение в одно место. (Это
особенно желательно, когда вы пишете на Django приложение с от-
крытым исходным кодом, которое должно быть полезно как можно
большему количеству людей.)

def book_list(request):
books = Book.objects.order_by(‘name’)
return render_to_response(‘book_list.html’, {‘books’: books})

Итак рассмотрим чему же следует Джанго MVT или MVC
Вроде мы уже отделяли безнес логику от шаблонов отображения, то есть например выполнили запрос к БД,
потом результаты запроса выгрузили в шаблон и отправили пользователю
Уровень доступа к данным тоже должен быть сильно абстаргированным от используемой технологии храниения данных
а доступ к ним осуществляться через классы, чтобы в настройках при переходе с одной БД, на другую могли изменить только один класс


В совокупности эти три части – логика доступа к данным, бизнес-логика и логика отображения – составляют шаблон
проектирования, который иногда называют Модель-Представление-Контроллер (Model-View-Controller
– MVC). Здесь «модель» относится к уровню доступа к данным,  «представление» – к той части системы, которая выбирает, что отображать и как отображать,
то есть к нашим функция, которые передают что-то в шаблоны, а контроллер - в зависимости от введеннных данных пользователем рещает, какое представление ей использовать
в нашем случае это файл urls, в котором описанны отображения

•• M – часть, касающаяся доступа к данным; соответствует уровню ра-
боты с базой данных в Django; он описывается в этой главе;
•• V – часть, касающаяся решения о том, что и как отображать, соот-
ветствует представлениям и шаблонам;
•• C – часть, которая передает управление некоторому представлению
в зависимости от того, что ввел пользователь, реализована самим
фреймворком с помощью конфигурации URL, которая говорит, ка-
кую функцию представления вызывать для данного URL.

Так как часть C - то есть логика вывода отображений в зависимости от пользовательских даных, то она реализованна саммим фреймверком в настроках УРЛов
А самый сок происходит в моделях, шаюлоназ и представлениях то все это хозяйство стали называть MVT фреймверком

•• M означает «Model» (модель), то есть уровень доступа к данным. На этом уровне сосредоточена вся информация о данных: как получить
к ним доступ, как осуществлять контроль, каково их поведение, каковы отношения между данными.
•• T означает «Template» (шаблон),уровень отображения. Здесь принимаются решения, относящиеся к представлению данных:
как следует отображать данные на веб-странице или в ином документе.
•• V означает «View» (представление), уровень бизнес-логики. На этом
уровне расположена логика доступа к модели и выбора подходящего
шаблона(или шаблонов). Можно сказать, что это мост между моде лями и шаблонами.

То есть на уровне представлений и расположенна бизнес логика, тут беруться данные из базыЮ а потом выводяться в шаблоны
 то есть представления - это контроллеры, а шаблоны - представления

 БД настраивается в settings.py
 в этом разделе
 DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

ENGINE -  работет со след postgresql, postgresql_psycorp2, mysql, sqllite3, oracle
USERP
PASSWORD
HOST
PORT

СУБД MySQL – особый случай. Если значение этого параметра начи-
нается с символа слеша (‘/’) и вы работаете с MySQL, то соединение
с MySQL будет устанавливаться через указанный UNIX-сокет, на-
пример:
DATABASE_HOST = ‘/var/run/mysql’

В предыдущем мы создали проект, это в совокупности конфигурация нескольких приложений,
- проект - это несколько приложений + конфигурация этих приложений
- к проекту прилагается всего 1 требование, он должен содержать всего 1 файл, в котором есть список подключаемых бакз
и указанны шаблоны
 - Приложение – это переносимый инкапсулированный набор функций Django, обычно включающий модели и представления, которые
являются частью одного пакета Python.
- В комлект джанго входит несколько приложений, напрмиер автоматизированая система подачи коментов и админка

В несложном сайте достаточно 1 приложения в сложныхнужно разбивать например  системы торговли и админку
На самом деле совершенно не обязательно вообще создавать приложе-
ния, что с очевидностью следует из примеров функций представлений,
с которыми мы уже встречались выше. Мы просто создавали файл views.
py, добавляли в него функции представлений и в конфигурации URL
указывали на эти функции. Никаких «приложений» не понадобилось.

Однако есть одно негласное соглашение, если используем БД, то создавать приложение нужно
python manage.py startapp books

Модель в Django представляет собой описание данных
в базе, представленное на языке Python. Это эквивалент SQL-команды
CREATE TABLE, только написанный не на SQL, а на Python, и включающий
гораздо больше, чем определения столбцов. В Django модель используется,
чтобы выполнить SQL-код и вернуть удобные структуры данных
Python, представляющие строки из таблиц базы данных. Кроме того,
модели позволяют представить высокоуровневые концепции, для которых
в SQL может не быть аналогов.

Кароч модель - класс или функция, что-то выбирают из БД и результат представляют в удобном виде

'''