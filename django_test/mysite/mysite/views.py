'''
Джанго это фреймворк заменяющий рутинную работу программиста, предстваим себе ручной код для вывода каких ниюудь динамических данных из БД
#!/usr/bin/env python

import MySQLdb

print “Content-Type: text/html\n”
print “<html><head><title>Книги</title></head>”
print “<body>”
print “<h1>Книги</h1>”
print “<ul>”

connection = MySQLdb.connect(user=’me’, passwd=’letmein’, db=’my_db’)
cursor = connection.cursor()
cursor.execute(“SELECT name FROM books ORDER BY pub_date DESC LIMIT 10”)

for row in cursor.fetchall():
print “<li>%s</li>” % row[0]

print “</ul>”
Но ту очень неудобно изменять если у нас куча таких страниц, что нужно например, чтобы подключаться к БД из разных скриптов, это нужно менять подключения во всех файлах
или выносить в отдельную функцию
- Что делать - если нужно постоянно выводить строку Content-Type: text/html\n
- Что делать, если код будет испольняться на разных серверах и меняьтся БД и пароль - все нужно вынести в отдельный файл
А что если дизайнер не знающий Питона захочет изменить дизайн.
Тогда логика выборки из БД, должны быть отделена от ее HTML представления. Именно этим и занимайется фреймворк
Теперь реализуем это разбив на логику процессы
Прежде всего, отметим, что мы разбили его на три Python-файла (models.py, views.py, urls.py) и один HTML-шаблон
(latest_books.html)

# models.py (таблицы базы данных)

from django.db import models
class Book(models.Model):
    name = models.CharField(max_length=50)
    pub_date = models.DateField()

#views.py (бизнес-логика)
from django.shortcuts import render_to_response
from models import Book

def latest_books(request):
    book_list = Book.objects.order_by(‘-pub_date’)[:10]
    return render_to_response(‘latest_books.html’, {‘book_list’: book_list})

# urls.py (конфигурация URL)

from django.conf.urls.defaults import *
import views
urlpatterns = patterns(‘’,
    (r’^latest/$’, views.latest_books),)

# latest_books.html (шаблон)

<html><head><title>Книги</title></head>
<body>
<h1>Книги</h1>
<ul>
{% for book in book_list %}
<li>{{ book.name }}</li>
{% endfor %}
</ul>
</body></html>

#Это модель, т.к непосредственно собирает данные из базы
В файле models.py - содержиться описание таблицы БД, предоставленной классом Питона. Он назівется моделью т.к обеспечивает доступ к БД через свои свойства либо методі
Т.е простой код на Питоне никак н связанный с SQL запросами


#Это вроде бы представление, но еще пока не понятно, может и контроллер
В файле views.py - также представленна бизнес логика приложения, в нем описанно как эти данные выводит, например по сколько и в каком порядке, т.е - это представление

В файле urls.py - описывается, какое представление нужно вызвать для данного URL, заданного в виде шаблона
например если URL был /latest/ то соответсвенно вывести последних 10 книг
Файл latest_books.html – это HTML-шаблон,
описывающий дизайн
страницы. В нем используется специальный язык шаблонов,
вклю-
чающий основные логические конструкции, например {% for book in
book_list %}.

Все это и представляет собой современный разновидность паттерна проектирования MVC - когда запросы доступа к данным отделены от лонгики их обработки и
Файл latest_books.html – это HTML-шаблон,
описывающий дизайн
страницы. В нем используется специальный язык шаблонов,
вклю-
чающий основные логические конструкции, например {% for book in
book_list %}.

В основе своей Джанго протой набор библиотек написанных на Питон
В общем проект это как-ббы сама библиотека Джанго но уже настроенная и заточенная под этот проек
Проект представляет собой набор параметров настройки отдельного экземпляра Django, в том числе параметров базы данных, параметров самого фреймворка и параметров приложения.
django-admin.py startproject mysite - начать новый проект при этом создаются несколько файлов

__init__.py - просто файл чтобы Питон расматривал папку как пакет модулей
manage.py - командная утилита, позводяет различными способами взаимодействовать с Python, такое как создание пользователей, смена паролей, рассылка почты и т.д

settings.py - настройка самого проекта, т.е какие там либы используются, с каких хостов разре
urls.py: URL-адреса для данного проекта Django. Это «оглавление»
вашего сайта. Пока что оно пусто.

python manage.py runserver 0.0.0.0:8000 - можно запустить на всех интерфейсах, чтобы пользователь с любого ПК спокойно мог к нему подключиться
От-
метим, что при этом определяются два ключевых свойства страницы: ее
содержимое (строка “Hello world”) и URL (http://www.example.com/hello.
html или, быть может, http://www.example.com/files/hello.html, если вы
решили поместить файл в подкаталог).
При работе с Django вы определяете те же свойства, но по-другому. Содер-
жимое страницы порождает функция представления, а URL задается
в настройках URL. Сначала напишем функцию представления.

Итак сделаем первое предстваление, контроллер - он берет данные от модели и переделывеат их в нужном нам формает


Итак как выяснилось основной принцип вего этого - слабая связанность компонентов, т.е когда изменения в базе, окнтроллере и дизайне могут безболезненно производить изменения в каком либо компоненте
Например если хотим изменитьь УРЛ какой-то страницы, то достаточно внести изменения в конфигурацию УРЛ не трогая само представление, можно несколько УРЛОВ связать с одним представлением
'''
from django.http import HttpResponse, HttpRequest, Http404
from django.template import Template, Context
from django.template.loader import get_template
from django.shortcuts import render_to_response
import sys
import datetime
request=HttpRequest
#Для начала нам нужен будет класс HttpResponse
#Любая функция в в представлении должна принимать по крайней мере 1 параметр - это запрос, с ним можно ничего не делать, но по крайней мере нужно принять
#он является экземпларом класса HTTP.Request, тут мы не используем request, но а так он должен быть первым параметром представления, а имя функции может быть любым
#только чтобы функция стала функцией представления, она должна соответсвовать двум условиям
#1) Принимать HTTP_Request
#2) Возвращать HTTP_Response

#Представление 1 - статическое содержимое
def hello(request):
    #print(sys.path)
    #print(request)
    return HttpResponse('Hello world')

#Если же мы сейчас обратимся к серверу, то он просто выведет Welcom to Django, т.к проет еще не знает ничего о нашем представлении, т.е нужно дописать что при обращении к такому-то URL должно активироваться такое-то представление
#т.е мы как-юа не загрузили еще эту страницу. Для связи представление с URL используется механизм конфигурации URL
#Можно сказать, что конфигурация URL - это оглавление, т.е переходя по такому-то URL - должно открыться такое-то представление
#т.е как-бы говорим для этого УРЛ вызови такую-то функцию, для этого вот эту и т.д например при обращеннии к /foo/ выполнить функцию foo_views которая находиться в файле views.py
#Конфигурация URLов храниться в urls.py в конечном счете все будет выглядет примерно так
# from django.conf.urls.defaults import * - импортируем все объекты из модуля django.conf.urls.defaults
# urlpatterns = patterns(‘’,) во второй строке вызывается функция patterns, а возвращенный результат сохраняется в переменной urlpatterns, тут аргумент - пустая строка, с ее помощью можно задать общий префикс для функции представления
#Главное здесь переменная urlpatterns - которую Django ожидает найти ф кофигурацииУРЛов. Она ставит в соответсвие УРЛ и обрабатівающий ее код

#Представление2 - динмаческое содержимое,
def print_date(request):
    now=datetime.datetime.now()
    str='<html><body>Сейчас : {0}</body></html>'.format(now)
    return HttpResponse(str)

def print_date2(request):
    #Теперь воспользуемся системой шаблонов, но тут  мы просто встроим код в питон
    now = datetime.datetime.now()
    t = Template(' <html> <body> Сейчас{{current_date}}.</body></html>')
    c=Context({'current_date':now})
    html=t.render(c)
    return HttpResponse(html)

#По правильному шаблон нужно сохранять в html файле а потом подгружать отдельно
def print_date3(request):
    #Теперь воспользуемся системой шаблонов, но тут  мы просто встроим код в питон
    now = datetime.datetime.now()
    with open('C:\MyScripts\django_test\mysite\mysite\mytemplate.html','r') as fh:
        t = Template(fh.read())
    c=Context({'current_date':now})
    html=t.render(c)
    return HttpResponse(html)
'''
Но такой подход трудно назвать элегантным по нескольким причинам:
•• Не обрабатывается случай отсутствия файла, как отмечено в ком-
ментарии. Если файл mytemplate.html не существует или недоступен
для чтения, то вызов open() возбудит исключение IOError.
•• Местоположение шаблона
зашито в код. Применение такой техники
в каждой функции представления означало бы необходимость ду-
блирования местоположения, не говоря уже о том, сколько текста
придется набирать!
•• Содержит много повторяющегося шаблонного
кода. Вы могли бы за-
няться решением более интересных задач вместо того, чтобы писать
обращения к функциям open(), fp.read() и fp.close().

Для загрузки шаблонов у Джанго есть свой АПИ
Для начала нужно указать путь с шаблонаим храниться
откройте файл settings.
py и найдите в нем параметр TEMPLATE_DIRS.
потом загрузить шаболн с помощью функции get_template('mytemplate.html')

Чтобы найти шаблон
в файловой системе,
функция get_template() поо-
чередно соединяет каталоги, перечисленные в параметре TEMPLATE_DIRS,
с именем шаблона.
Например, если TEMPLATE_DIRS содержит путь ‘/home/
django/mysite/templates’, то get_template() будет искать шаблон
в файле /
home/django/mysite/templates/current_datetime.html.
Если функция get_template() не найдет шаблон
с указанным именем,
она возбудит исключение TemplateDoesNotExist. Чтобы посмотреть, как
это выглядит, запустите сервер разработки Django командой python
manage.py runserver, находясь в каталоге проекта. Затем в броузере вве-
дите адрес страницы, активирующей представление current_datetime
(например, http://127.0.0.1:8000/time/). В предположении, что параметр
DEBUG равен True и шаблон
current_datetime.html еще не создан, вы увиди-
те страницу ошибок Django, на которой большими буквами сообщается
об ошибке TemplateDoesNotExist (рис. 4.1).
'''
def print_date4(request):
    #Теперь воспользуемся системой шаблонов, но тут  мы просто встроим код в питон
    now = datetime.datetime.now()
    t=get_template('mytemplate.html')
    c=Context({'current_date':now})
    html=t.render(c)
    return HttpResponse(html)
def print_date5(request):
    now = datetime.datetime.now()
    #выгладит очень просто и сама делает рендеринг, т.е вставляет пременные в шаблон (шаблон, словарь)
    return render_to_response('mytemplate.html', {'current_date': now})

#Можно поступить еще ленивей, использовать словарь localals(), который в качестве ключей содержит имена перемнных

def print_date6(request):
    current_date= datetime.datetime.now()
    #выгладит очень просто и сама делает рендеринг, т.е вставляет пременные в шаблон (шаблон, словарь)
    return render_to_response('mytemplate.html', locals())
#Можно также шаблоны распределять по подкаталогам тогда нужно обращаться так return render_to_response('subdir/mytemplate.html'
#Также можно включать один например часто используемый шаблон в другой тегом
#{% include 'nav.html' %}
#В качестве аргумента ему передается имя включаемого шаблона,которое может быть переменной или строковым литералом в одиноч-
#ных или двойных кавычках
#Или мы можем путь хранить в переменной
#{% include template_name %}

def current_section(request):
    current_section='Torodos'
    return render_to_response('mypage.html', locals())


#Также есть еще функция render_to_response
#А вообще идиома Джанго - это загрузить шаблон, передать в него контекст и вернуть объект HTTPResponse
#то прогеры подумали объеденили все это в одну строчку кода render_to_response(), находящейся в модуле
#django.shortcuts

#Представление3 - динмаческое содержимое, в зависимости от УРЛ, напримерв книжном магазине с главной страницы могут нажать УРЛ чтобы он соотвествовал какой-то книге /books/243/ и /books/81196/
#здесь мы созадим представление которое увеличивает текущее время, на заданное кол-во часов /time/plus/1 /time/plus/2 /time/plus/3

#Можно по неопытности сдлеать так
#urlpatterns = patterns(‘’,
#(‘^time/$’, current_datetime),
#(‘^time/plus/1/$’, one_hour_ahead),
#(‘^time/plus/2/$’, two_hours_ahead),
#(‘^time/plus/3/$’, three_hours_ahead),
#(‘^time/plus/4/$’, four_hours_ahead),
#Но мы воспользуемся типичной регулркой ограничив 99 часами
#url(r'^hours/plus/(\d{1,2})/$', hours_ahead)
#r - это сырая строка, говорящая о том, что не нужно обрабатывать обратные слеши, всеь текст читается так как он есть
#Круглые скобки, служат для сохранения текста, совпавшего с шаблоном
#Тут мы сначала закодили УРЛ а потом перешли к описанию, такой подход лучше наверное, так как мы точно заранее знаем набор УРЛов
#и параметры будущих функций
#)

#Если раньше писали на ПХП то ГЕТ запросом передавалась перменная, которую можно обработать, такое можно и в Джанго, однако его философия - красивые УРЛ адреса
#воспользоваться параметром в строке запроса – что-то вроде /time/plus?hours=3, тоже можно передавая переменную, но красивее будет так /time/plus/3

#Если закоментировать перобразование в инт тип, то нам будет выведенно предупреждение с ошибкай, эта страница содержит основнойтип ошибки вверху
#В offset - попадает наша сохраненная регулярка с цифрами и получим ошибку
#по Traceback - трассировке мы можем смотреть, какие функции и пременные как скакали по модулям, смотреть нужно снизу вверх итак мы видим


#c:\MyScripts\django\mysite\mysite\views.py in hours_ahead

#dt=datetime.datetime.now()+datetime.timedelta(hours=offset)
#▼ Local vars
#Variable 	Value
#offset 	    '88'

#request 	<WSGIRequest: GET '/hours/plus/88/'>


#Потом следующий кадр, тл есть функция в которую были переданны данные
#C:\Users\anteo\AppData\Local\Programs\Python\Python35-32\lib\site-packages\django\core\handlers\base.py in _get_response
#response = wrapped_callback(request, *callback_args, **callback_kwargs)

#▼ Local vars
#Variable 	Value
#callback 	<function hours_ahead at 0x0333C0C0>
#callback_args 	('88',)
#callback_kwargs 	{}
#middleware_method 	<bound method CsrfViewMiddleware.process_view of <django.middleware.csrf.CsrfViewMiddleware object at 0x03382810>>
#request 	<WSGIRequest: GET '/hours/plus/88/'>
#resolver 	<RegexURLResolver 'mysite.urls' (None:None) ^/>
#resolver_match ResolverMatch(func=mysite.views.hours_ahead, args=('88',), kwargs={}, url_name=None, app_names=[], namespaces=[])
#response None
#self    <django.core.handlers.wsgi.WSGIHandler object at 0x02CFC370>
#wrapped_callback <function hours_ahead at 0x0333C0C0>


#В Request Information можно посмотреть информацию о запросе и всякие переменные

#Share this traceback on a public Web site - отправляет трассировку на dpaste.com, и возвращает ссылку, чтобы этой трассировкой можно было поделиться на форуме

#Settings - находяться параметры данного экземпляра Джанго


def hours_ahead(request,offset):

    try:
        offset=int(offset)
    except ValueError:
        raise Http404
    #Вот здесь к объекту datetime мы добавляем datetime.timedelta - то есть такой же объект с датой но со сдвигом по времени
    dt=datetime.datetime.now()+datetime.timedelta(hours=offset)
    #Если добавить assert False - то выведеться страница ошибок
    #print('Test message') а вот это будет выводиться в консоли сервера, также можем использовать для просмотра переменных
    #assert False и в низу в Local vars посмотреть нужные нам пермеенные
    html='<html><body>Через {0} часов будет {1}'.format(offset,dt)
    return HttpResponse(html)

def you_input(request,word1,word2):
    html='Вы ввели '+word1+' '+word2
    return HttpResponse(html)


#Теперь рассмотрим шаблоны, которые отделяют HTML код от обарботчика, раньше мы страивали HTML код прямо в представление, а такого нельзя делать
#1) При любом изменении дизайна нужно менять HTML код страницы в самом коде представления во всех местах, что оченьне удобно
#2) Программирование на Питон - это бэкенд, а вот программирование всяких интерфейсов - это фронтенд, обычно их ведут разные люди, поэтому важно отделять дизайн от логики
#Стуркутура шаюлонов
#Шаблон - предстваляет собой структуру текста, предназначенную для отделения предстваления документа от его данных. В нем могут встречаться маркеры и простые логические конструкции, управляюшие отображением документа
#обычно шаблоны применяются для порождения ХТМЛ разметки, но в Джанго они подходят для любых форматов
'''
В результате встает типичный для веб-разработки вопрос: как
устранить дублирование общих областей, например, встречающейся на
всех страницах сайта области навигации?
Классически эта проблема решалась с помощью включения на сторо-
не сервера, то есть размещения на HTML-странице директив, требую-
щих включения других страниц. Как было описано выше, Django поддерживает
такой подход с помощью шаблонного
тега {% include %}. Но предпочтительным является более элегантное решение, называемое на-
следованием шаблонов.Для начала создается скелет из неменяющихся частей, таких как футеры, ботомы
меню, а потом добавлять только изменяющиейся части. Он и определяет блоки изменяющиеся в дочерних шаблонах

Можно делать типа так
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN”>
<html lang=”ru”>
<head>
<title>Время в будущем</title>
</head>
<body>
<h1>Мой сайт точного времени</h1>
<p>Через {{ hour_offset }} часов будет {{ next_time }}.</p>

<hr>
<p>Спасибо, что посетили мой сайт.</p>
</body>
</html>

Как видим общая часть обозначенна, т.е меняется только какой-то нутряк
можно было бы разнести на фоотер и хеадер фрагменты, например на 2 html файла а потом включать один
и другой в страницы
Стратегия включения хорошо подходит для верха и низа страницы.
А вот с серединой придется повозиться. В данном примере обе страни-
цы имеют заголовок – <h1>Мой сайт точного времени</h1>, но включить его
в файл header.html нельзя, потому что тег <title> на этих страницах раз-
личается. Если бы мы перенесли <h1> в header.html, то пришлось бы перености и тайтл, тогда
бы мы не смогли сделать разные заголовки
В Джанго все вывернуто наизнанку, то есть в родительском шаблоне мы определям различающиеся
'''
def current_date(request):
    current_date= datetime.datetime.now()
    #выгладит очень просто и сама делает рендеринг, т.е вставляет пременные в шаблон (шаблон, словарь)
    return render_to_response('current_date.html', locals())
'''
В том нашем файле содержиться какой скилет он расширяет а также куда вставить
перемнную current_date

Объясним, как это работает. Во время загрузки шаблона
current_datetime.
html система
видит тег {% extends %}, означающий, что это дочерний шаблон.
Поэтому система
тут же загружает родительский шаблон
– в дан-
ном случае base.html.
Теперь система
обнаруживает три тега {% block %} в файле base.html и за-
меняет их содержимым дочернего шаблона.
Таким образом, будет ис-
пользован заголовок, определенный в {% block title %}, и содержимое,
определенное в {% block content %}.
Отметим, что в дочернем шаблоне
не определен блок footer, поэтому система
шаблонов
берет значение из родительского шаблона.
Содержимое
тега {% block %} в родительском шаблоне
используется, когда нет ника-
кого другого варианта.

Наследование никак не сказывается на контексте шаблона.
Иными
словами, любой шаблон
в дереве наследования имеет доступ ко всем
шаблонным
переменным, заданным в контексте.
Обычно используется такая схема
1)Шаблон дед - общий для всего сайта
2) Шаблоны отцы - с немного изменными например под фото галаерю, форум
3) Шаблоны сыны страниц уже под отдельные фото, форумы и т.д

Если в шаблоне
встречается тег {% extends %}, то он должен быть са-
мым первым тегом. В противном случае механизм наследования ра-
ботать не будет.
•• Вообще говоря, чем больше тегов {% block %} в базовых шаблонах,
тем
лучше. Напомним, что дочерние шаблоны
не обязаны переопреде-
лять все блоки родительского шаблона,
поэтому во многих блоках
можно определить разумные значения по умолчанию и переопреде-
лять только те, что необходимы. Лучше, когда точек встраивания
в избытке, а не в недостатке.
•• При обнаружении в нескольких шаблонах
повторяющихся фраг-
ментов кода имеет смысл перенести этот код в тег {% block %} в роди-
тельском шаблоне.
•• Чтобы получить содержимое блока в родительском шаблоне,
исполь-
зуйте конструкцию {{ block.super }}. Эта «магическая» переменная
содержит результат отображения текста из родительского шаблона.
Это бывает полезно, когда требуется дополнить содержимое роди-
тельского блока, а не переопределить его полностью.
•• Нельзя определять в одном шаблоне
несколько тегов {% block %} с од-
ним и тем же именем. Это ограничение связано с тем, что тег block
работает в обоих направлениях. Иначе говоря, блок – не просто
дыра, которую нужно заполнить, а еще и содержимое, которым эта
дыра заполняется в родительском шаблоне.
Если бы в одном шаблоне
встретились несколько одноименных тегов {% block %}, родитель
этого шаблона
не знал бы, содержимое какого блока использовать.
•• Шаблон,
имя которого задано в теге {% extends %}, загружается так
же, как это делает функция get_template(), то есть имя шаблона
кон-
катенируется с путем, заданным параметром TEMPLATE_DIRS.
•• Обычно аргументом {% extends %} является строка, но может быть
и переменная, если имя родительского шаблона
становится известно
только на этапе выполнения. Это открывает возможность для раз-
личных хитроумных динамических трюков.
'''